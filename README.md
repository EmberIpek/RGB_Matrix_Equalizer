# RGB_Matrix_Equalizer
Evolution of an LED equalizer project for the Raspberry Pi using a microphone module, ADC, and an 8x32 LED matrix; v0-3 are proof-of-concept lead ups to v4
https://www.youtube.com/watch?v=Y1ANiDLVMYM

Must enable high-speed I2C protocol with the command sudo nano /boot/config.txt and add dtparam=i2c_arm_baudrate=400000

Must run v4 with sudo

I used a combination of labs 3 and 4 as a starting point for my LED equalizer project. Using the check_distance() and map() functions and the dictionary I used in lab 3, I had an RGB LED change color based on the distance measured by the HC-SR04 ultrasonic sensor. Next, I added functions to interpolate between the colors for smooth gradient transitions and modified distance_to_color() to return a value that was in between the color segments in rainbow_colors. Then I connected a microphone module to the PCF8591 ADC to convert the analog input to digital, passed in the digital input through I2C and used the same functions to generate colors based on the intensity of the sound. I ran into trouble trying to extract frequency information through the ADC and switched to trying to work with an INMP441 microphone, which uses I2S protocol. This microphone required the sounddevice library to function, which I installed through the terminal and enabled I2S by adding the line dtparam=i2s=on into /boot/config.txt. This enabled the use of I2S pins on the Raspberry Pi, however I was getting no output, so I switched back to the original analog microphone I was using and modified /boot/config.txt to enable high-speed I2C with dtparam=i2c_arm_baudrate=400000. I continued trying to register different frequencies on my RGB LEDs, but the LEDs kept giving inconsistent outputs such as registering some noise when it was quiet, or on the opposite end of the spectrum, could not distinguish much change depending on the combination and values of pull-up resistors, decoupling capacitors, and bypass capacitors I used. Interestingly, at some points I could visually see a capacitor charging and discharging as a high intensity noise suddenly pushed the LED to the blue range, and then it would oscillate up and down between colors as it slowly settled back to baseline red, which was a fascinating effect to observe. When I found a somewhat happy medium to minimize noise and smooth signal spikes, I moved on to working with an 8x32 LED matrix and signal processing by using numpyâ€™s fft() to separate the samples into 256 different component frequencies with a sample delay of 100us corresponding to a 10kHz theoretical sample rate. I noticed that as I pushed the delay to be smaller, I started getting noise in my input, and as I increased the number of samples, the processing delay introduced unacceptably high latency. Again, I found a happy medium but still get a lot of noise on the highest frequency end of the spectrum. I suspect that it may either be oversampled, adding in high frequency noise, or that it may be undersampled due to processing delays, leading to aliasing and folding. Through further research, I have found that the Raspberry Pi has four cores, and it is possible to explicitly set the code to be multi-threaded. I believe it may be possible to improve the frequency resolution by dedicating one core to only sampling the input and storing them in a buffer for processing by the other cores. This has become a passion project for me, and I plan on continuing to tweak this and try to push the range of frequencies it can effectively pick up by utilizing multi-threading and/or running the signal through various filters until I am satisfied with the results, then possibly add buttons to change the number of channels and switch between different modes. Next steps: SPI ADC for higher sampling rate (although suspect that the limiting factor is processing speed), multi-threaded processing.

Update 5/15/25: I have ditched the PCF8591 ADC and mystery microphone that came with the Adeept kit in favor of an MCP3201 (12-bit SPI ADC) for faster data rates and a MAX4466 microphone. Will also experiment with giving the LED matrix its own external power supply from batteries, so as not to draw too much power from the RPi and reduce processing speed. Next steps: set up circular buffer, set one core to sample continuously and add samples to a circular buffer for processing by other cores. Push data rate to be as high as possible, and reduce number of computations within fft function to minimize processing latency.
